def solution(n):
    # 1 = 0 - 홀수는 채울수 없음 : 홀수 제외하고 생각
    # 2 = 3 - 블록의 경우의 수
    # 4 = 11 - 3 * 3 (n=2 각각 3 2개) + 2 (짝수에서 생기는 특이케이스)
    # 6 = 4케이스 * 3 (11개 경우에 기본 패턴 3가지 경우가 나오는 수)
    #     + (2 * sum(4케이스 + 2케이스)) : 각 케이스에서 나온 특이 케이스가 앞 또는 뒤에 붙는 경우
    #     + 2 : 6에서 발생하는 특이케이스
    # 따라서 DP[n] = DP[n-2]*3 + 2(DP[n-4]+DP[n-6]+...+DP[0]) + 2

    # 동적계획법 DP 사용방식
    if n % 2 != 0:
        return 0
    else:
        lastIdx = int(n / 2)                    # 홀수 경우는 애초에 제외해서 시간 줄이기
        DP = [0 for i in range(lastIdx + 1)]    # 기록용 배열
        DP[1] = 3

        for i in range(2, lastIdx + 1):
            DP[i] = DP[i - 1] * 3               # 이전 케이스에 기본 패턴의 수 3 곱하기
            DP[i] += sum(DP[:i - 1]) * 2        # 특수케이스가 앞에 나오거나 뒤에 나올수 있으므로 *2
            DP[i] += 2                          # 짝수에서 발생하는 특이케이스 2 더하기

        DP[i] = DP[i] % 1000000007

    return DP[lastIdx]                          # 마지막 경우의 수 출력